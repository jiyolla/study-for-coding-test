import sys
from collections import deque


def solve():
    read = sys.stdin.readline
    for k in range(int(read())):
        n = int(read())
        t = list(map(int, read().split()))
        m = int(read())
        # t[i]는 작년에 i등을 한 팀의 번호를 반환한다
        # 주어진느 m개의 순서쌍은 관련된 정보의 상대성을 보장해준다.
        # 뭘 하는 문제지?
        # 위상정렬이기한데
        # 위상정렬이 뭐였지?
        # DAG에서 그래프를 전체 순회할 수 있는 방법 중 한 가지를 제시하는 것이다.
        # 현재 주어진 팀의 등수가 DAG인가?
        # 작년 팀 등수는 DAG가 맞다. 아주 정갈한 DAG이다.
        # 그래프를 순회할 수 있는 방법이 하나 밖에 없고, 순회와 그래프 자체가 전달하는 의미가 거의 똑같다.
        # 올해의 팀 등수에 관한 그래프가 있을 것이다.
        # 작녀과는 달리 비공개이다. 그러나 부분적으로 추론할 수 있는 정보들이 있다.
        # 작년에 1 2 3 4 5였다고 해보자.
        # 올해는 기본적으로 작년 정보를 가져와서 수정을 하는데
        # 올해에 (1 3)이라는 정보가 주어진다면, 1등 팀과 3등의 팀 상대적 순서가 바뀌었다는 것이다.
        # 즉 기존에는 1->2->3->...였다면
        # 올해는 적어도 1->...->3일 수가 없다는 것이다.
        # ...->3->...->1->...이렇게 되어야 하는 것이다.
        # 이게 가능한가?
        # 불가능하다. 1등이 팀이 3등 팀 뒤로 올려면 2등팀이 문제가 된다.
        # 2등 팀에 대한 추가 정보가 없기 때문에, 2등팀에 관한 정보는 그대로 라고 생각해야 한다.
        # 하지만 2등팀이 1등팀과 3등팀과의 상호관계를 유지하면서 1등팀이 3등팀 뒤로 올 수는 없다.
        # 따라서 이 정보는 오류가 있는 정보이다.
        # 맞나? 본부가 모든 변화점을 다 발표해야만 하는 것인가?
        # 아니면 일부만 발표한 것으로 간주하고 명시하지만 않으면 우리 마음대로 추측해도 된다는 것인가?
        # 후자가 맞다면 3->2->1->4->5가 맞는데, 그런데 3->1->4->2->5도 맞다. 명시된 정보가 없기 때문이다.
        # 아무리 봐도 후자로 해석하면 거의 모든 문제가 ?로 나타날 것 같다.
        # 예시를 한번 보자.
        # 응 역시 전자의 해석이 맞다.
        # 자 문제의 초보적인 이해는 된 거 같다.
        # 어떻게 해결하지?
        # 그냥 단순하게 주어진 쌍대로 직방으로 링크를 만들면 어떻게 될까?
        # 1 2 3 4 5에 (1 3)이 주어지면
        # 1->2
        # 2->3
        # 3->4, 1
        # 4->5
        # 흠...
        # 먄약에 (1 3) (2 3)이 주어졌으면
        # 1->2
        # 2->3
        # 3->1 2 4
        # 4->5
        # 잘 모르겠다
        # 응 좋은 생각이 떠올랐다.
        # 작년에 순서 자체를 그래프로 보기보다는 유일한 순뢰로 보는 것이다.
        # 1 2 3 4 5이면
        # 그래프가 1->2->3->4->5인 게 아니라
        # 1->2,3,4,5; 2->3,4,5; 3->4,5; 4->5
        # 이런식으로 모든 자기 뒤에 올 수 있는 원소들을 다 넣어주는 것이다
        # 그러면 저렇게 단순하게 수정해도 먹힐 듯?
        # (1 3) (2 3)을 넣으면
        # 아니 그전에 일반적으로 (ㄱ ㄴ)이 들어오면
        # ㄱ에 가서 ㄴ을 확인하고 있으면 ㄴ을 없애고, ㄴ에 ㄱ을 추가하고
        # 없으면 ㄴ을 추가하고, ㄴ에 ㄱ을 없애는 식으로 하면 된다
        # 1->2,4,5: 2->4,5: 3->1,2,4,5: 4->5이다
        # #호호호 안 봐도 31245밖에 안 되는 게 보이군 ㅎㅎ ㅇㅋ 해결.
        # 먼저 t를 기반으로 그래프를 만들자.
        # graph[i] = ith팀 앞에 수 있는 팀의 리스트
        graph = [[] for _ in range(n + 1)]
        for i in range(n):
            graph[t[i]] += t[:i]
        for _ in range(m):
            a, b = map(int, read().split())
            if b in graph[a]:
                graph[a].remove(b)
                graph[b].append(a)
            else:
                graph[b].remove(a)
                graph[a].append(b)
        q = deque()
        ans = []
        for i in range(1, n + 1):
            if not graph[i]:
                q.append(i)
                ans += [str(i)]
        while q:
            cur = q.popleft()
            for i in range(1, n + 1):
                if cur in graph[i]:
                    graph[i].remove(cur)
                    if not graph[i]:
                        q.append(i)
                        ans += [str(i)]
        print(' '.join(ans) if len(ans) == n else 'IMPOSSIBLE')


solve()
