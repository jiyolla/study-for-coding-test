import sys
sys.setrecursionlimit(10**7)

def solve():
    read = sys.stdin.readline
    n = int(read())
    seq = list(map(int, read().split()))
    m = int(read())

    # 질문의 수가 매우 많다. 즉, 모든 질문을 처음부터 다시 시작해서 풀면 안 된다.
    # 기존에 답했던, 혹시 미리 작성한 테이블을 기준으로 최대 log 뭐시기 시간에 해결해야 한다.
    # 하위 문제를 풀어서 현재 문제를 푸는 구조를 떠오르게 함으로 DP로 해결하는 게 맞다.
    # 하위 문제와 상위 문제의 상관 관계가 어떻게 될까?
    # 팰린드롬의 판정이 어떻게 이루어지는가?
    # 양끝에서 서로 같은지 비교하며 같을 때에 계속 더 안쪽에 있는 원소를 확인하면 된다.
    # 웅. 만약에 1 9 를 푸는데, 1 7 이 팰린드롬이라는 사실을 알고 있다면, 예시로 보자
    # 1 2 3 4 3 2 1 a b라고 해보자. 1 7이 팰린드롬이다. 1 9는 절대 팰린드롬이 될 수 없다.
    # 그리고 2 8이라는 팰린드롬이라는 사실은 1 9를 푸는데 상당한 도움을 준다. 우리는 추가적으로 1과 9원소만 확인하면 된다.
    # 팰린드롬이 될 수 없다는 정보는 일단 제치고, 2 8과 같은 하위 문제의 유형을 좀 정리하자면 다음과 같다.
    # a b라는 질문이 주어졌을 때, a+1 b-1에 대한 답이 있는지 찾아보는 것이다.
    # 1 7과 같은 정보로 빠르게 거르는 가능성을 제거하는 정보는 어떻게 체계적으로 활용하는가?
    # 조금 애매할 수 있다. a b라는 질문이 주어졌을 때, 흠... 일단 이 정보 활용하지 않고 구현해보자.
    cache = {}

    def dp(s, e):
        if (s, e) in cache:
            return cache[(s, e)]
        elif s - e >= 0:
            return 1
        elif seq[s - 1] == seq[e - 1]:
            cache[(s, e)] = dp(s + 1, e - 1)
        else:
            cache[(s, e)] = 0
        return cache[(s, e)]
    for _ in range(m):
        print(dp(*list(map(int, read().split()))))
    # 런타임 에러가 떴다. 아마도 IndexError이지 않을까 한다.
    # e>=s이기 때문에 e == s인 경우, e == s + 1인 경우에는 즉시 종결된다.
    # e - s == 2이면, 다음 호출에는 e == s가 되면서 문제가 없다.
    # 음 어디서 문제가 생기는 거지...
    # 아 recursion limit이다. 하...
    # 틀렸다라......
    # 흠... 이게 틀릴 수가 있나...?
    # 메모리초과도 시간초과도 아니고 틀렸다라...팰린드롬의 정의를 잘못알고 있나?
    # 베이스 케이스 처리에서 문제가 있었다.


solve()
